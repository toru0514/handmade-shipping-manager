# UC-001: 購入情報を自動取得する

## 基本情報

| 項目 | 内容 |
|-----|------|
| ユースケースID | UC-001 |
| ユースケース名 | 購入情報を自動取得する |
| アクター | システム |
| 優先度 | 高 |
| ステータス | 未実装 |

## 概要

Gmailに届いた購入通知メールをトリガーとして、メールから注文IDを抽出し、Playwrightでminne/creemaの管理画面にアクセスして購入者情報を取得する。取得した情報はスプレッドシートに保存する。

## 事前条件

- Gmail APIが有効化されていること
- Google Sheets APIが有効化されていること
- minne/creemaのアカウント認証情報が設定されていること
- スプレッドシートが作成済みであること

## 事後条件

- 購入情報がスプレッドシートに記録されている
- 注文ステータスが「発送前」として登録されている

## 基本フロー

1. システムは定期的にGmailをポーリングする
2. システムはminne/creemaからの購入通知メールを検出する
3. システムはメール本文から注文IDを抽出する
4. システムはPlaywrightでminne/creemaの管理画面にログインする
5. システムは注文IDを使って注文詳細ページにアクセスする
6. システムは以下の購入者情報を取得する：
   - 注文番号
   - 購入者名
   - 購入者住所（郵便番号、都道府県、市区町村、番地、建物名）
   - 購入者電話番号
   - 購入品名
   - 購入金額
   - 購入日時
   - プラットフォーム名（minne / creema）
7. システムは取得した情報をスプレッドシートに新規行として追加する
8. システムは注文ステータスを「発送前」に設定する
9. システムはUC-002（新規注文を通知する）を呼び出す

## 代替フロー

### 3a. 注文IDの抽出に失敗した場合
1. システムはエラーログを記録する
2. システムはSlackでエラーを通知する
3. メールは「要確認」としてマークされる

### 4a. ログインに失敗した場合
1. システムはリトライを3回まで試みる
2. 3回失敗した場合、エラーログを記録する
3. システムはSlackでログインエラーを通知する

### 6a. 購入者情報の取得に失敗した場合
1. システムはエラー内容をログに記録する
2. システムはSlackでエラーを通知する
3. 注文は「取得失敗」ステータスで記録される

### 7a. 重複する注文番号が存在する場合
1. システムは重複を検出する
2. システムは新規追加をスキップする
3. システムはログに重複スキップを記録する

## 関連ドメインルール

このユースケースで適用されるドメインルール（[詳細](../domain/README.md#ドメインルールdomain-rules)）:

| ルールID | ルール名 | 説明 |
|---------|---------|------|
| DR-ORD-001 | 注文ID一意性 | 同一注文IDの注文は重複登録できない |
| DR-ORD-002 | 必須項目 | 購入者名、住所、商品名は必須 |
| DR-PLT-001 | 対応プラットフォーム | minne / creema のみ対応 |
| DR-ADR-001 | 郵便番号形式 | 7桁の数字であること |
| DR-ADR-002 | 都道府県 | 47都道府県のいずれかであること |

## 非機能要件

- メール取得の間隔は5分以内とする
- Playwright処理は1件あたり30秒以内に完了する

## 技術的考慮事項

### Gmail監視

```typescript
// 概念的なコード例
const checkForNewOrders = async () => {
  const gmail = google.gmail({ version: 'v1', auth });

  // 未読の購入通知メールを検索
  const res = await gmail.users.messages.list({
    userId: 'me',
    q: 'from:(minne OR creema) subject:購入 is:unread',
  });

  for (const message of res.data.messages || []) {
    const detail = await gmail.users.messages.get({
      userId: 'me',
      id: message.id,
    });

    const orderId = extractOrderId(detail.data);
    await fetchOrderDetails(orderId);
  }
};
```

### Playwrightでの情報取得

```typescript
// 概念的なコード例
const fetchOrderDetails = async (orderId: string, platform: Platform) => {
  const browser = await chromium.launch();
  const page = await browser.newPage();

  // プラットフォームにログイン
  await loginToPlatform(page, platform);

  // 注文詳細ページにアクセス
  await page.goto(`https://${platform}.com/orders/${orderId}`);

  // 購入者情報を取得
  const buyerInfo = await page.evaluate(() => {
    return {
      name: document.querySelector('.buyer-name')?.textContent,
      postalCode: document.querySelector('.postal-code')?.textContent,
      address: document.querySelector('.address')?.textContent,
      phone: document.querySelector('.phone')?.textContent,
      // ...
    };
  });

  await browser.close();
  return buyerInfo;
};
```

### 認証情報の管理

- minne/creemaの認証情報は環境変数または暗号化されたストレージに保存
- セッションCookieを保持し、再ログインを最小化
- 2段階認証への対応が必要な場合がある

## 画面・UI

このユースケースはバックグラウンド処理のため、専用画面は存在しない。
エラー発生時はSlackで通知される。

## データ

### 入力データ
- Gmailの購入通知メール
- minne/creemaの注文詳細ページ

### 出力データ（スプレッドシート）

| カラム名 | 型 | 必須 | 説明 |
|---------|-----|------|------|
| order_id | string | ○ | 注文番号 |
| platform | string | ○ | プラットフォーム名（minne/creema） |
| buyer_name | string | ○ | 購入者名 |
| buyer_postal_code | string | ○ | 郵便番号 |
| buyer_prefecture | string | ○ | 都道府県 |
| buyer_city | string | ○ | 市区町村 |
| buyer_address1 | string | ○ | 番地 |
| buyer_address2 | string | | 建物名（任意） |
| buyer_phone | string | | 電話番号 |
| product_name | string | ○ | 購入品名 |
| price | number | | 購入金額 |
| ordered_at | datetime | ○ | 購入日時 |
| status | string | ○ | ステータス（発送前/発送済み） |
| created_at | datetime | ○ | 登録日時 |
| updated_at | datetime | ○ | 更新日時 |

## 関連ユースケース

- UC-002: 新規注文を通知する（本ユースケース完了後に実行）

## 備考

- minne/creemaのUI変更に追従するメンテナンスが必要
- プラットフォームの利用規約を確認し、スクレイピングが許可されていることを確認する
- レート制限に注意し、適切な間隔でアクセスする
- 将来的にはプラットフォームがAPIを提供した場合は移行を検討
